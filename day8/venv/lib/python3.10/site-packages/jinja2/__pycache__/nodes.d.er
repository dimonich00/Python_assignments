##[pylyzer] failed /home/dmitry/progs/python/WISCourse/Python_assignments/day8/venv/lib/python3.10/site-packages/jinja2/nodes.py 1736025949 34579

.inspect = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.operator = pyimport "<failure>"


.t = pyimport "<failure>"


.___v_desugar_1 = pyimport "<failure>"

.deque: Never
.___v_desugar_2 = pyimport "__init__"
.__init__ = pyimport "__init__"
.Markup: {markupsafe.Markup}
.___v_desugar_3 = pyimport "utils"
.utils = pyimport "utils"
._PassArg: ClassType

._NodeBound: Never
._binop_to_func: Never
._uaop_to_func: Never
._cmpop_to_func: Never
.Impossible: ClassType
.Impossible <: global::Exception

.NodeType: ClassType
.NodeType <: Type
.NodeType.__new__: (mcs: Obj, name: Obj, bases: Never, d: global::Dict!(_: global::GenericDict)) -> Never

.EvalContext: ClassType

.get_eval_context: (node: Obj, ctx: Obj) -> Never
.Node: ClassType
.Node.environment: Never
.Node.lineno: Int
.Node.__call__: (*fields: Obj, **attributes := Obj) -> nodes.Node
.Node.fields: Never
.Node.attributes: Never
.Node.abstract: {True}
.Node.iter_fields: (self: nodes.Node, exclude: Structural({.__contains__ = (self: Never, Obj) -> Bool}) := {None} and Structural({.__contains__ = (self: Never, Obj) -> Bool}), only: Obj := {None}) -> NoneType
.Node.iter_child_nodes: (self: nodes.Node, exclude: Structural({.__contains__ = (self: Never, Obj) -> Bool}) := {None} and Structural({.__contains__ = (self: Never, Obj) -> Bool}), only: Obj := {None}) -> NoneType
.Node.find: (self: nodes.Node, node_type: global::HomogenousTuple(ClassType) or ClassType) -> {None}
.Node.find_all: (self: nodes.Node, node_type: global::HomogenousTuple(ClassType) or ClassType) -> global::Iterable(Never)
.Node.set_ctx: (self: nodes.Node, ctx: Str) -> nodes.Node
.Node.set_lineno: (self: nodes.Node, lineno: Int, override: Bool := Bool) -> nodes.Node
.Node.set_environment: (self: nodes.Node, environment: Obj) -> nodes.Node
.Node.__eq__: (self: nodes.Node, other: Obj) -> Bool
.Node.__hash__: (self: Obj) -> Int
.Node.__repr__: (self: nodes.Node) -> Str
.Node.dump: (self: nodes.Node) -> Str

.Stmt: ClassType
nodes = pyimport "nodes"
.Stmt <: .Node
.Stmt.abstract: {True}

.Helper: ClassType
.Helper <: .Node
.Helper.abstract: {True}

.Template: ClassType
.Template <: .Node
.Template.body: Never
.Template.fields: global::Tuple([{"body"}])

.Output: ClassType
.Output <: .Stmt
.Output.nodes: Never
.Output.fields: global::Tuple([{"nodes"}])

.Extends: ClassType
.Extends <: .Stmt
.Extends.fields: global::Tuple([{"template"}])

.For: ClassType
.For <: .Stmt
.For.else_: Never
.For.target: .Node
.For.body: Never
.For.iter: .Node
.For.recursive: Bool
.For.test: Never
.For.fields: global::Tuple([{"target"}, {"iter"}, {"body"}, {"else_"}, {"test"}, {"recursive"}])

.If: ClassType
.If <: .Stmt
.If.test: .Node
.If.else_: Never
.If.body: Never
.If.elif_: Never
.If.fields: global::Tuple([{"test"}, {"body"}, {"elif_"}, {"else_"}])

.Macro: ClassType
.Macro <: .Stmt
.Macro.body: Never
.Macro.defaults: Never
.Macro.name: Str
.Macro.args: Never
.Macro.fields: global::Tuple([{"name"}, {"args"}, {"defaults"}, {"body"}])

.CallBlock: ClassType
.CallBlock <: .Stmt
.CallBlock.fields: global::Tuple([{"call"}, {"args"}, {"defaults"}, {"body"}])

.FilterBlock: ClassType
.FilterBlock <: .Stmt
.FilterBlock.fields: global::Tuple([{"body"}, {"filter"}])

.With: ClassType
.With <: .Stmt
.With.targets: Never
.With.values: Never
.With.body: Never
.With.fields: global::Tuple([{"targets"}, {"values"}, {"body"}])

.Block: ClassType
.Block <: .Stmt
.Block.scoped: Bool
.Block.body: Never
.Block.name: Str
.Block.required: Bool
.Block.fields: global::Tuple([{"name"}, {"body"}, {"scoped"}, {"required"}])

.Include: ClassType
.Include <: .Stmt
.Include.fields: global::Tuple([{"template"}, {"with_context"}, {"ignore_missing"}])

.Import: ClassType
.Import <: .Stmt
.Import.fields: global::Tuple([{"template"}, {"target"}, {"with_context"}])

.FromImport: ClassType
.FromImport <: .Stmt
.FromImport.fields: global::Tuple([{"template"}, {"names"}, {"with_context"}])

.ExprStmt: ClassType
.ExprStmt <: .Stmt
.ExprStmt.node: .Node
.ExprStmt.fields: global::Tuple([{"node"}])

.Assign: ClassType
.Assign <: .Stmt
.Assign.fields: global::Tuple([{"target"}, {"node"}])

.AssignBlock: ClassType
.AssignBlock <: .Stmt
.AssignBlock.fields: global::Tuple([{"target"}, {"filter"}, {"body"}])

.Expr: ClassType
.Expr <: .Node
.Expr.abstract: {True}
.Expr.as_const: (self: nodes.Expr, eval_ctx: Obj := Obj) -> Never
.Expr.can_assign: (self: nodes.Expr) -> Bool

.BinExpr: ClassType
.BinExpr <: .Expr
.BinExpr.right: .Expr
.BinExpr.operator: Str
.BinExpr.left: .Expr
.BinExpr.fields: global::Tuple([{"left"}, {"right"}])
.BinExpr.abstract: {True}
.BinExpr.as_const: (self: nodes.BinExpr, eval_ctx: Obj := Obj) -> Never

.UnaryExpr: ClassType
.UnaryExpr <: .Expr
.UnaryExpr.operator: Str
.UnaryExpr.node: .Expr
.UnaryExpr.fields: global::Tuple([{"node"}])
.UnaryExpr.abstract: {True}
.UnaryExpr.as_const: (self: nodes.UnaryExpr, eval_ctx: Obj := Obj) -> Never

.Name: ClassType
.Name <: .Expr
.Name.ctx: Str
.Name.name: Str
.Name.fields: global::Tuple([{"name"}, {"ctx"}])
.Name.can_assign: (self: nodes.Name) -> Bool

.NSRef: ClassType
.NSRef <: .Expr
.NSRef.attr: Str
.NSRef.name: Str
.NSRef.fields: global::Tuple([{"name"}, {"attr"}])
.NSRef.can_assign: (self: nodes.NSRef) -> Bool

.Literal: ClassType
.Literal <: .Expr
.Literal.abstract: {True}

.Const: ClassType
.Const <: .Literal
.Const.value: Never
.Const.fields: global::Tuple([{"value"}])
.Const.as_const: (self: nodes.Const, eval_ctx: Obj := Obj) -> Never
.Const.from_untrusted: (cls: (Obj) -> nodes.Const, value: Obj, lineno: Obj := {None}, environment: Obj := {None}) -> nodes.Const

.TemplateData: ClassType
.TemplateData <: .Literal
.TemplateData.data: Str
.TemplateData.fields: global::Tuple([{"data"}])
.TemplateData.as_const: (self: nodes.TemplateData, eval_ctx: Obj := Obj) -> Str

.Tuple: ClassType
.Tuple <: .Literal
.Tuple.items: Never
.Tuple.ctx: Str
.Tuple.fields: global::Tuple([{"items"}, {"ctx"}])
.Tuple.as_const: (self: nodes.Tuple, eval_ctx: Obj := Obj) -> global::Tuple([Never])
.Tuple.can_assign: (self: nodes.Tuple) -> Bool

.List: ClassType
.List <: .Literal
.List.items: Never
.List.fields: global::Tuple([{"items"}])
.List.as_const: (self: nodes.List, eval_ctx: Obj := Obj) -> global::List!(Never, _: Nat)

.Dict: ClassType
.Dict <: .Literal
.Dict.items: Never
.Dict.fields: global::Tuple([{"items"}])
.Dict.as_const: (self: nodes.Dict, eval_ctx: Obj := Obj) -> global::Dict({Never: Never})

.Pair: ClassType
.Pair <: .Helper
.Pair.key: .Expr
.Pair.value: .Expr
.Pair.fields: global::Tuple([{"key"}, {"value"}])
.Pair.as_const: (self: nodes.Pair, eval_ctx: Obj := Obj) -> global::Tuple([Never, Never])

.Keyword: ClassType
.Keyword <: .Helper
.Keyword.key: Str
.Keyword.value: .Expr
.Keyword.fields: global::Tuple([{"key"}, {"value"}])
.Keyword.as_const: (self: nodes.Keyword, eval_ctx: Obj := Obj) -> global::Tuple([Str, Never])

.CondExpr: ClassType
.CondExpr <: .Expr
.CondExpr.expr2: Never
.CondExpr.expr1: .Expr
.CondExpr.test: .Expr
.CondExpr.fields: global::Tuple([{"test"}, {"expr1"}, {"expr2"}])
.CondExpr.as_const: (self: nodes.CondExpr, eval_ctx: Obj := Obj) -> Never

.args_as_const: |T: Type, Type_39554: Type, Type_39472 <: global::Iterable(?T), Type_39536: Type, Type_39508: Type, Type_36357 <: Structural({.args = ?39472; .dyn_kwargs = ?39536 and ?39554; .dyn_args = ?39500 and ?39508}), Type_39500: Type|(node: Type_36357, eval_ctx: Obj) -> global::Tuple([global::List!(T, _: Nat), global::Dict({T: Never})])
.Type__FilterTestCommon: ClassType
.Type__FilterTestCommon <: .Expr
.Type__FilterTestCommon.kwargs: Never
.Type__FilterTestCommon.dyn_args: Never
.Type__FilterTestCommon.name: Str
.Type__FilterTestCommon.dyn_kwargs: Never
.Type__FilterTestCommon.node: .Expr
.Type__FilterTestCommon.args: Never
.Type__FilterTestCommon.fields: global::Tuple([{"node"}, {"name"}, {"args"}, {"kwargs"}, {"dyn_args"}, {"dyn_kwargs"}])
.Type__FilterTestCommon.abstract: {True}
.Type__FilterTestCommon._is_filter: {True}
.Type__FilterTestCommon.as_const: (self: nodes.Type__FilterTestCommon, eval_ctx: Obj := Obj) -> Never

.Filter: ClassType
.Filter <: .Type__FilterTestCommon
.Filter.node: Never
.Filter.as_const: (self: nodes.Filter, eval_ctx: Obj := Obj) -> Never

.Test: ClassType
.Test <: .Type__FilterTestCommon
.Test._is_filter: {False}

.Call: ClassType
.Call <: .Expr
.Call.kwargs: Never
.Call.dyn_args: Never
.Call.dyn_kwargs: Never
.Call.node: .Expr
.Call.args: Never
.Call.fields: global::Tuple([{"node"}, {"args"}, {"kwargs"}, {"dyn_args"}, {"dyn_kwargs"}])

.Getitem: ClassType
.Getitem <: .Expr
.Getitem.arg: .Expr
.Getitem.node: .Expr
.Getitem.ctx: Str
.Getitem.fields: global::Tuple([{"node"}, {"arg"}, {"ctx"}])
.Getitem.as_const: (self: nodes.Getitem, eval_ctx: Obj := Obj) -> Never

.Getattr: ClassType
.Getattr <: .Expr
.Getattr.attr: Str
.Getattr.node: .Expr
.Getattr.ctx: Str
.Getattr.fields: global::Tuple([{"node"}, {"attr"}, {"ctx"}])
.Getattr.as_const: (self: nodes.Getattr, eval_ctx: Obj := Obj) -> Never

.Slice: ClassType
.Slice <: .Expr
.Slice.start: Never
.Slice.step: Never
.Slice.stop: Never
.Slice.fields: global::Tuple([{"start"}, {"stop"}, {"step"}])
.Slice.as_const: (self: nodes.Slice, eval_ctx: Obj := Obj) -> Never

.Concat: ClassType
.Concat <: .Expr
.Concat.nodes: Never
.Concat.fields: global::Tuple([{"nodes"}])
.Concat.as_const: (self: nodes.Concat, eval_ctx: Obj := Obj) -> Str

.Compare: ClassType
.Compare <: .Expr
.Compare.expr: .Expr
.Compare.ops: Never
.Compare.fields: global::Tuple([{"expr"}, {"ops"}])
.Compare.as_const: (self: nodes.Compare, eval_ctx: Obj := Obj) -> Never

.Operand: ClassType
.Operand <: .Helper
.Operand.expr: .Expr
.Operand.op: Str
.Operand.fields: global::Tuple([{"op"}, {"expr"}])

.Mul: ClassType
.Mul <: .BinExpr
.Mul.operator: {"*"}

.Div: ClassType
.Div <: .BinExpr
.Div.operator: {"."}

.FloorDiv: ClassType
.FloorDiv <: .BinExpr
.FloorDiv.operator: {".."}

.Add: ClassType
.Add <: .BinExpr
.Add.operator: {"+"}

.Sub: ClassType
.Sub <: .BinExpr
.Sub.operator: {"-"}

.Mod: ClassType
.Mod <: .BinExpr
.Mod.operator: {"Type_"}

.Pow: ClassType
.Pow <: .BinExpr
.Pow.operator: {"**"}

.And: ClassType
.And <: .BinExpr
.And.operator: {"and"}
.And.as_const: (self: nodes.And, eval_ctx: Obj := Obj) -> Never

.Or: ClassType
.Or <: .BinExpr
.Or.operator: {"or"}
.Or.as_const: (self: nodes.Or, eval_ctx: Obj := Obj) -> Never

.Not: ClassType
.Not <: .UnaryExpr
.Not.operator: {"not"}

.Neg: ClassType

.Pos: ClassType

.EnvironmentAttribute: ClassType
.EnvironmentAttribute <: .Expr
.EnvironmentAttribute.name: Str
.EnvironmentAttribute.fields: global::Tuple([{"name"}])

.ExtensionAttribute: ClassType
.ExtensionAttribute <: .Expr
.ExtensionAttribute.identifier: Str
.ExtensionAttribute.name: Str
.ExtensionAttribute.fields: global::Tuple([{"identifier"}, {"name"}])

.ImportedName: ClassType
.ImportedName <: .Expr
.ImportedName.importname: Str
.ImportedName.fields: global::Tuple([{"importname"}])

.InternalName: ClassType
.InternalName <: .Expr
.InternalName.name: Str
.InternalName.__call__: () -> nodes.InternalName
.InternalName.fields: global::Tuple([{"name"}])

.MarkSafe: ClassType
.MarkSafe <: .Expr
.MarkSafe.expr: .Expr
.MarkSafe.fields: global::Tuple([{"expr"}])
.MarkSafe.as_const: (self: nodes.MarkSafe, eval_ctx: Obj := Obj) -> markupsafe.Markup

.MarkSafeIfAutoescape: ClassType
.MarkSafeIfAutoescape <: .Expr
.MarkSafeIfAutoescape.expr: .Expr
.MarkSafeIfAutoescape.fields: global::Tuple([{"expr"}])
.MarkSafeIfAutoescape.as_const: (self: nodes.MarkSafeIfAutoescape, eval_ctx: Obj := Obj) -> Never

.ContextReference: ClassType
.ContextReference <: .Expr

.DerivedContextReference: ClassType
.DerivedContextReference <: .Expr

.Continue: ClassType
.Continue <: .Stmt

.Break: ClassType
.Break <: .Stmt

.Scope: ClassType
.Scope <: .Stmt
.Scope.body: Never
.Scope.fields: global::Tuple([{"body"}])

.OverlayScope: ClassType
.OverlayScope <: .Stmt
.OverlayScope.context: .Expr
.OverlayScope.body: Never
.OverlayScope.fields: global::Tuple([{"context"}, {"body"}])

.EvalContextModifier: ClassType
.EvalContextModifier <: .Stmt
.EvalContextModifier.options: Never
.EvalContextModifier.fields: global::Tuple([{"options"}])

.ScopedEvalContextModifier: ClassType
.ScopedEvalContextModifier <: .EvalContextModifier
.ScopedEvalContextModifier.body: Never
.ScopedEvalContextModifier.fields: global::Tuple([{"body"}])

._failing_new: (*args: Obj, **kwargs := Obj) -> Never


