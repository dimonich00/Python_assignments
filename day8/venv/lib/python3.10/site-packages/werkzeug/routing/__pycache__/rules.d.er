##[pylyzer] failed /home/dmitry/progs/python/WISCourse/Python_assignments/day8/venv/lib/python3.10/site-packages/werkzeug/routing/rules.py 1736025949 32510
.___v_desugar_1 = pyimport "<failure>"
.<failure> = pyimport "<failure>"
.annotations: Never
.ast = pyimport "<failure>"


.re = pyimport "<failure>"


.t = pyimport "<failure>"


.___v_desugar_2 = pyimport "<failure>"

.dataclass: Never
.___v_desugar_3 = pyimport "<failure>"

.Template: Never
.___v_desugar_4 = pyimport "<failure>"

.CodeType: Never
.___v_desugar_5 = pyimport "<failure>"

.quote: Never
.___v_desugar_6 = pyimport "<failure>"

.iter_multi_items: Never
.___v_desugar_7 = pyimport "<failure>"

._urlencode: Never
.___v_desugar_8 = pyimport "converters"
.converters = pyimport "converters"
.ValidationError: {converters.ValidationError}

.Weighting: ClassType
.Weighting <: Never
.Weighting.number_static_weights: Int
.Weighting.static_weights: global::List!(Never, _: Nat)
.Weighting.number_argument_weights: Int
.Weighting.argument_weights: global::List!(Int, _: Nat)

.RulePart: ClassType
.RulePart.suffixed: Bool
.RulePart.final: Bool
.RulePart.static: Bool
rules = pyimport "rules"
.RulePart.weight: .Weighting
.RulePart.content: Str
.RulePart.__call__: () -> rules.RulePart

._part_re: Never
._simple_rule_re: Never
._converter_args_re: Never
._PYTHON_CONSTANTS: global::Dict!({{"False"}: {False}, {"True"}: {True}, {"None"}: {None}})
._find: (value: Str, target: Str, pos: Int) -> Int
._pythonize: (value: Str) -> NoneType or Float or Str
.parse_converter_args: Never
.RuleFactory: ClassType
.RuleFactory.__call__: () -> rules.RuleFactory
.RuleFactory.get_rules: (self: rules.RuleFactory, map: map.Map) -> Never

.Subdomain: ClassType
.Subdomain <: .RuleFactory
.Subdomain.rules: Never
.Subdomain.subdomain: Str
.Subdomain.__call__: (subdomain: Str, rules: Obj) -> rules.Subdomain
.Subdomain.get_rules: (self: rules.Subdomain, map: map.Map) -> NoneType

.Submount: ClassType
.Submount <: .RuleFactory
.Submount.path: Str
.Submount.rules: Never
.Submount.__call__: (path: Str, rules: Obj) -> rules.Submount
.Submount.get_rules: (self: rules.Submount, map: map.Map) -> NoneType

.EndpointPrefix: ClassType
.EndpointPrefix <: .RuleFactory
.EndpointPrefix.prefix: Str
.EndpointPrefix.rules: Never
.EndpointPrefix.__call__: (prefix: Str, rules: Obj) -> rules.EndpointPrefix
.EndpointPrefix.get_rules: (self: rules.EndpointPrefix, map: map.Map) -> NoneType

.RuleTemplate: ClassType
.RuleTemplate.rules: Never
.RuleTemplate.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> rules.RuleTemplate
.RuleTemplate.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> rules.RuleTemplate

.RuleTemplateFactory: ClassType
.RuleTemplateFactory <: .RuleFactory
.RuleTemplateFactory.context: global::Dict!({Str: Never})
.RuleTemplateFactory.rules: Never
.RuleTemplateFactory.__call__: Never
.RuleTemplateFactory.get_rules: (self: rules.RuleTemplateFactory, map: map.Map) -> NoneType

._ASTT: Never
._prefix_names: (src: Str, expected_type: global::HomogenousTuple(ClassType) or ClassType) -> Never
._CALL_CONVERTER_CODE_FMT: {"self._converters[{elem!r}].to_url()"}
._IF_KWARGS_URL_ENCODE_CODE: {"if kwargs:\n    params = self._encode_query_vars(kwargs)\n    q = \"?\" if params else \"\"\nelse:\n    q = params = \"\"\n"}
._IF_KWARGS_URL_ENCODE_AST: Never
._URL_ENCODE_AST_NAMES: Never
.Rule: ClassType
.Rule <: Factory
.Rule._converters: global::Dict!({Str: converters.BaseConverter})
.Rule.strict_slashes: NoneType or Bool
.Rule.is_leaf: Never
.Rule.merge_slashes: NoneType or Bool
.Rule.alias: Bool
.Rule.endpoint: Never
map = pyimport "map"
.Rule.map: map.Map
.Rule.redirect_to: Never
.Rule.host: NoneType or Str
.Rule.rule: Never
.Rule.subdomain: NoneType or Str
.Rule.is_branch: Never
.Rule.build_only: Bool
.Rule._trace: global::List!(Never, _: Nat)
.Rule.methods: Never
.Rule._parts: global::List!(rules.RulePart, _: Nat)
.Rule.defaults: Never
.Rule.websocket: Bool
.Rule.__call__: (string: Str, defaults: Obj := Obj, subdomain: NoneType or Str := NoneType or Str, methods: Obj := Obj, build_only: Bool := Bool, endpoint: Obj := Obj, strict_slashes: NoneType or Bool := NoneType or Bool, merge_slashes: NoneType or Bool := NoneType or Bool, redirect_to: Obj := Obj, alias: Bool := Bool, host: NoneType or Str := NoneType or Str, websocket: Bool := Bool) -> rules.Rule
.Rule.empty: (self: rules.Rule) -> rules.Rule
.Rule.get_empty_kwargs: (self: rules.Rule) -> global::GenericDict
.Rule.get_rules: (self: rules.Rule, map: map.Map) -> Never
.Rule.refresh: (self: rules.Rule) -> NoneType
.Rule.bind: (self: rules.Rule, map: map.Map, rebind: Bool := Bool) -> NoneType
.Rule.get_converter: Never
.Rule._encode_query_vars: (self: rules.Rule, query_vars: Obj) -> Str
.Rule._parse_rule: (self: rules.Rule, rule: Str) -> NoneType
.Rule.compile: (self: rules.Rule) -> NoneType
.Rule._get_func_code: (code: Obj, name: Str) -> Never
.Rule._compile_builder: (self: rules.Rule, append_unknown: Bool := Bool) -> Never
.Rule.build: (self: rules.Rule, values: Obj, append_unknown: Bool := Bool) -> global::Tuple([Str, Str]) or NoneType
.Rule.provides_defaults_for: (self: rules.Rule, rule: rules.Rule) -> Bool
.Rule.suitable_for: |E: Type, R: Type, Type_16898 <: Structural({.__contains__ = (self: Never, ?R) -> Bool; .__getitem__ = (self: Obj, ?E) -> ?E})|(self: rules.Rule, values: Type_16898, method: NoneType or Str := {None} and NoneType or Str) -> Bool
.Rule.build_compare_key: (self: rules.Rule) -> global::Tuple([Int, Int, Int])
.Rule.__eq__: (self: rules.Rule, other: Obj) -> Bool
.Rule.__hash__: Never
.Rule.__str__: (self: rules.Rule) -> Str
.Rule.__repr__: (self: rules.Rule) -> Str

