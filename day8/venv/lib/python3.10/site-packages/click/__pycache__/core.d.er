##[pylyzer] failed /home/dmitry/progs/python/WISCourse/Python_assignments/day8/venv/lib/python3.10/site-packages/click/core.py 1736025949 114748
.enum = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.errno = pyimport "<failure>"


.inspect = pyimport "<failure>"


.os = pyimport "<failure>"


.sys = pyimport "<failure>"


.t = pyimport "<failure>"


.___v_desugar_1 = pyimport "<failure>"

.abc: Never
.___v_desugar_2 = pyimport "<failure>"

.contextmanager: Never
.___v_desugar_3 = pyimport "<failure>"

.ExitStack: Never
.___v_desugar_4 = pyimport "<failure>"

.update_wrapper: Never
.___v_desugar_5 = pyimport "<failure>"

._: Never
.___v_desugar_6 = pyimport "<failure>"

.ngettext: Never
.___v_desugar_7 = pyimport "<failure>"

.repeat: Never
.___v_desugar_8 = pyimport "types"
.types = pyimport "types"
.TracebackType: Never
.___v_desugar_9 = pyimport "__init__"
.__init__ = pyimport "__init__"
.types: Never
.___v_desugar_10 = pyimport "exceptions"
.exceptions = pyimport "exceptions"
.Abort: Never
.___v_desugar_11 = pyimport "exceptions"

.BadParameter: Never
.___v_desugar_12 = pyimport "exceptions"

.ClickException: Never
.___v_desugar_13 = pyimport "exceptions"

.Exit: Never
.___v_desugar_14 = pyimport "exceptions"

.MissingParameter: Never
.___v_desugar_15 = pyimport "exceptions"

.UsageError: Never
.___v_desugar_16 = pyimport "formatting"
.formatting = pyimport "formatting"
.HelpFormatter: {formatting.HelpFormatter}
.___v_desugar_17 = pyimport "formatting"

.join_options: (options: global::Iterable(Never)) -> global::Tuple([Str, Bool])
.___v_desugar_18 = pyimport "globals"
.globals = pyimport "globals"
.pop_context: () -> NoneType
.___v_desugar_19 = pyimport "globals"

.push_context: (ctx: Obj) -> NoneType
.___v_desugar_20 = pyimport "parser"
.parser = pyimport "parser"
._flag_needs_value: Obj
.___v_desugar_21 = pyimport "parser"

.OptionParser: Never
.___v_desugar_22 = pyimport "parser"

.split_opt: (opt: Str) -> global::Tuple([Str, Str])
.___v_desugar_23 = pyimport "termui"
.termui = pyimport "termui"
.confirm: (text: Str, default: Bool := Bool, abort: Bool := Bool, prompt_suffix: Str := Str, show_default: Bool := Bool, err: Bool := Bool) -> Bool
.___v_desugar_24 = pyimport "termui"

.prompt: (text: Str, default: Obj := Obj, hide_input: Bool := Bool, confirmation_prompt: Never := Never, Type: Obj := Obj, value_proc: (Str) -> Never := {None} and (Str) -> Never, prompt_suffix: Str := {": "} and Str, show_default: Bool := {True} and Bool, err: Bool := {False} and Bool, show_choices: Bool := {True} and Bool) -> Never
.___v_desugar_25 = pyimport "termui"

.style: |T <: Bool|(text: Obj, fg: T := T, bg: T := T, bold: Obj := Obj, dim: Obj := Obj, underline: Obj := Obj, overline: Obj := Obj, italic: Obj := Obj, blink: Obj := Obj, reverse: Obj := Obj, strikethrough: Obj := Obj, reset: Bool := Bool) -> Str
.___v_desugar_26 = pyimport "utils"
.utils = pyimport "utils"
._detect_program_name: (path: Bool := Bool, _main: Structural({.__package__ = Obj}) := Structural({.__package__ = Obj})) -> Str
.___v_desugar_27 = pyimport "utils"

._expand_args: |T: Type|(args: global::Iterable(T), user: Bool := Bool, env: Bool := Bool, glob_recursive: Bool := Bool) -> global::List!(T, _: Nat)
.___v_desugar_28 = pyimport "utils"

.echo: (message: Never := Never, file: global::Writable! := global::Writable!, nl: Bool := Bool, err: Bool := Bool, color: {None} := {None}) -> NoneType
.___v_desugar_29 = pyimport "utils"

.make_default_short_help: (help: Str, max_length: Int := Int) -> Str
.___v_desugar_30 = pyimport "utils"

.make_str: (value: Obj) -> Str
.___v_desugar_31 = pyimport "utils"

.PacifyFlushWrapper: Never

.F: Never
.V: Never
._complete_visible_commands: (ctx: Obj, incomplete: Str) -> NoneType
._check_multicommand: (base_command: Obj, cmd_name: Str, cmd: Obj, register: Bool := Bool) -> NoneType
.batch: |T :> global::Tuple([?T, ?U]), U: Type, T: Type|(iterable: global::Iterable(T), batch_size: Int) -> global::List!(T, _: Nat)
.augment_usage_errors: (ctx: Obj, param: Obj := Obj) -> Never
.iter_params_for_processing: |T :> core.Parameter, T: Type|(invocation_order: global::List(T, _: Nat) or global::Bytes or Str, declaration_order: global::Iterable(T)) -> global::List!(T, _: Nat)
.ParameterSource: ClassType
.ParameterSource <: Never
.ParameterSource.COMMANDLINE: Never
.ParameterSource.ENVIRONMENT: Never
.ParameterSource.DEFAULT: Never
.ParameterSource.DEFAULT_MAP: Never
.ParameterSource.PROMPT: Never

.Context: ClassType

.BaseCommand: ClassType
.BaseCommand.context_settings: Never
.BaseCommand.name: Never
.BaseCommand.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> Never
.BaseCommand.context_class: Never
.BaseCommand.allow_extra_args: {False}
.BaseCommand.allow_interspersed_args: {True}
.BaseCommand.ignore_unknown_options: {False}
.BaseCommand.to_info_dict: (self: core.BaseCommand, ctx: Obj) -> global::Dict!({{"name"}: Never})
.BaseCommand.__repr__: (self: core.BaseCommand) -> Str
.BaseCommand.get_usage: (self: core.BaseCommand, ctx: Obj) -> Str
.BaseCommand.get_help: (self: core.BaseCommand, ctx: Obj) -> Str
.BaseCommand.make_context: |Type_21071 :> {None}|(self: core.BaseCommand, info_name: Obj, args: Never, parent: Type_21071 := Type_21071 and Type_21071, **extra := Obj) -> Never
.BaseCommand.parse_args: (self: core.BaseCommand, ctx: Obj, args: Never) -> Never
.BaseCommand.invoke: (self: core.BaseCommand, ctx: Obj) -> Never
.BaseCommand.shell_complete: (self: core.BaseCommand, ctx: Obj, incomplete: Str) -> Never
.BaseCommand.main: (self: core.BaseCommand, args: Obj := Obj, prog_name: Obj := Obj, complete_var: Obj := Obj, standalone_mode: Obj := Obj, **extra := Obj) -> Never
.BaseCommand.main: (self: core.BaseCommand, args: Obj := Obj, prog_name: Obj := Obj, complete_var: Obj := Obj, standalone_mode: Bool := Bool, **extra := Obj) -> Never
.BaseCommand.main: (self: core.BaseCommand, args: Never := Never, prog_name: Str := Str, complete_var: Str := Str, standalone_mode: Bool := Bool, windows_expand_args: Bool := Bool, **extra := Obj) -> Never
.BaseCommand._main_shell_completion: (self: core.BaseCommand, ctx_args: Obj, prog_name: Str, complete_var: Str := Str) -> NoneType
.BaseCommand.__call__: (self: Obj, *args: Obj, **kwargs := Obj) -> Never

.Command: ClassType
core = pyimport "core"
.Command <: .BaseCommand
.Command.short_help: Never
.Command.add_help_option: Bool
.Command.help: Never
.Command.params: Never
.Command.options_metavar: Never
.Command._help_option: Never
.Command.callback: Never
.Command.hidden: Bool
.Command.deprecated: Bool
.Command.no_args_is_help: Bool
.Command.epilog: Never
.Command.__call__: (name: Obj, context_settings: Obj := Obj, callback: Obj := Obj, params: Obj := Obj, help: Obj := Obj, epilog: Obj := Obj, short_help: Obj := Obj, options_metavar: Obj := Obj, add_help_option: Bool := Bool, no_args_is_help: Bool := Bool, hidden: Bool := Bool, deprecated: Bool := Bool) -> core.Command
.Command.to_info_dict: (self: core.Command, ctx: Obj) -> Never
.Command.get_usage: (self: core.Command, ctx: Obj) -> Str
.Command.get_params: (self: core.Command, ctx: Obj) -> global::Iterable(core.BaseCommand)
.Command.format_usage: (self: core.Command, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.Command.collect_usage_pieces: (self: core.Command, ctx: Obj) -> global::List!(Str, 0) or global::List!(Never, 1)
.Command.get_help_option_names: (self: core.Command, ctx: Obj) -> global::List!(Never, _: Nat)
.Command.get_help_option: (self: core.Command, ctx: Obj) -> Never
.Command.make_parser: (self: core.Command, ctx: Obj) -> Never
.Command.get_help: (self: core.Command, ctx: Obj) -> Str
.Command.get_short_help_str: (self: core.Command, limit: Int := Int) -> Str
.Command.format_help: (self: core.Command, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.Command.format_help_text: (self: core.Command, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.Command.format_options: (self: core.Command, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.Command.format_epilog: (self: core.Command, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.Command.parse_args: |V <: Structural({.__and__ = (self: Never, ?R) -> ?O; .__len__ = (self: Never) -> Nat}), R: Type, O: Type|(self: core.Command, ctx: Obj, args: V) -> V
.Command.invoke: (self: core.Command, ctx: Obj) -> Never
.Command.shell_complete: (self: core.Command, ctx: Obj, incomplete: Str) -> Never

.MultiCommand: ClassType
.MultiCommand <: .Command
.MultiCommand._result_callback: Never
.MultiCommand.invoke_without_command: Bool
.MultiCommand.subcommand_metavar: Never
.MultiCommand.chain: Bool
.MultiCommand.no_args_is_help: Never
.MultiCommand.__call__: (name: Obj := Obj, invoke_without_command: Bool := Bool, no_args_is_help: Obj := Obj, subcommand_metavar: Obj := Obj, chain: Bool := Bool, result_callback: Obj := Obj, **attrs := Obj) -> core.MultiCommand
.MultiCommand.allow_extra_args: {True}
.MultiCommand.allow_interspersed_args: {False}
.MultiCommand.to_info_dict: (self: core.MultiCommand, ctx: Obj) -> Never
.MultiCommand.collect_usage_pieces: (self: core.MultiCommand, ctx: Obj) -> Never
.MultiCommand.format_options: (self: core.MultiCommand, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.MultiCommand.result_callback: (self: core.MultiCommand, replace: Bool := Bool) -> (f: Never) -> Never
.MultiCommand.format_commands: (self: core.MultiCommand, ctx: Obj, formatter: formatting.HelpFormatter) -> NoneType
.MultiCommand.parse_args: (self: core.MultiCommand, ctx: Obj, args: Obj) -> Never
.MultiCommand.invoke: (self: core.MultiCommand, ctx: Obj) -> Never
.MultiCommand.resolve_command: (self: core.MultiCommand, ctx: Obj, args: global::List!(Obj, 2)) -> global::Tuple([{None} or Str, Never, global::List!(Never, _: Nat)])
.MultiCommand.get_command: (self: core.MultiCommand, ctx: Obj, cmd_name: Str) -> Never
.MultiCommand.list_commands: (self: core.MultiCommand, ctx: Obj) -> global::List!(Str, 0)
.MultiCommand.shell_complete: (self: core.MultiCommand, ctx: Obj, incomplete: Str) -> Never

.Group: ClassType
.Group <: .MultiCommand
.Group.commands: Never
.Group.__call__: (name: Obj := Obj, commands: Obj := Obj, **attrs := Obj) -> core.Group
.Group.command_class: Never
.Group.group_class: Never
.Group.add_command: (self: core.Group, cmd: core.Command, name: Structural({.__or__ = (self: Never, Obj) -> Structural({.__or__ = (self: Never, Obj) -> Never})}) := {None} and Structural({.__or__ = (self: Never, Obj) -> Structural({.__or__ = (self: Never, Obj) -> Never})})) -> NoneType
.Group.command: (self: core.Group, __func: Obj) -> core.Command
.Group.group: (self: core.Group, __func: Obj) -> core.Group
.Group.group: (self: core.Group, *args: Obj, **kwargs := Obj) -> {Ellipsis}
.Group.group: (self: core.Group, *args: Obj, **kwargs := Obj) -> (f: Obj) -> core.Group
.Group.get_command: (self: core.Group, ctx: Obj, cmd_name: Str) -> Never
.Group.list_commands: (self: core.Group, ctx: Obj) -> global::List!(Never, _: Nat)

.CommandCollection: ClassType
.CommandCollection <: .MultiCommand
.CommandCollection.sources: Never
.CommandCollection.__call__: (name: Obj := Obj, sources: Obj := Obj, **attrs := Obj) -> core.CommandCollection
.CommandCollection.add_source: (self: core.CommandCollection, multi_cmd: core.MultiCommand) -> NoneType
.CommandCollection.get_command: (self: core.CommandCollection, ctx: Obj, cmd_name: Str) -> {None}
.CommandCollection.list_commands: (self: core.CommandCollection, ctx: Obj) -> global::List!(Never, _: Nat)

._check_iter: |I <: global::Iterable(?T), T: Type|(value: Obj) -> ?I.Iterator
.Parameter: ClassType
.Parameter.type: Never
.Parameter.envvar: Never
.Parameter.is_eager: Bool
.Parameter.expose_value: Bool
.Parameter.metavar: Never
.Parameter.nargs: Never
.Parameter.default: Never
.Parameter.callback: Never
.Parameter.multiple: Bool
.Parameter.required: Bool
.Parameter._custom_shell_complete: Never
.Parameter.__call__: (param_decls: Obj := Obj, Type: Obj := Obj, required: Bool := Bool, default: Obj := Obj, callback: Obj := Obj, nargs: Obj := Obj, multiple: Bool := Bool, metavar: Obj := Obj, expose_value: Bool := Bool, is_eager: Bool := Bool, envvar: Obj := Obj, shell_complete: Obj := Obj) -> core.Parameter
.Parameter.param_type_name: {"parameter"}
.Parameter.to_info_dict: (self: Never) -> global::Dict!({{"required"}: Bool, {"default"}: Never, {"envvar"}: Never, {"nargs"}: Never, {"name"}: Never, {"opts"}: Never, {"secondary_opts"}: Never, {"param_type_name"}: Never, {"multiple"}: Bool, {"type"}: Never})
.Parameter.__repr__: (self: core.Parameter) -> Str
.Parameter._parse_decls: (self: core.Parameter, decls: Obj, expose_value: Bool) -> Never
.Parameter.human_readable_name: (self: core.Parameter) -> Str
.Parameter.make_metavar: (self: core.Parameter) -> Str
.Parameter.get_default: (self: core.Parameter, ctx: Obj, call: Obj := Obj) -> {Ellipsis}
.Parameter.get_default: (self: core.Parameter, ctx: Obj, call: Bool := Bool) -> {Ellipsis}
.Parameter.get_default: (self: Never, ctx: Obj, call: Bool := Bool) -> Never
.Parameter.add_to_parser: (self: core.Parameter, parser: Obj, ctx: Obj) -> NoneType
.Parameter.consume_value: Never
.Parameter.type_cast_value: (self: core.Parameter, ctx: Obj, value: Obj) -> Never
.Parameter.value_is_missing: (self: core.Parameter, value: Obj) -> Bool
.Parameter.process_value: (self: core.Parameter, ctx: Obj, value: Obj) -> Never
.Parameter.resolve_envvar_value: (self: core.Parameter, ctx: Obj) -> {None}
.Parameter.value_from_envvar: (self: core.Parameter, ctx: Obj) -> Never
.Parameter.handle_parse_result: |Type_21621: Type|(self: core.Parameter, ctx: Obj, opts: Obj, args: Type_21621) -> global::Tuple([Never, Type_21621])
.Parameter.get_help_record: (self: core.Parameter, ctx: Obj) -> Never
.Parameter.get_usage_pieces: (self: core.Parameter, ctx: Obj) -> global::List!(Never, 0)
.Parameter.get_error_hint: (self: core.Parameter, ctx: Obj) -> Str
.Parameter.shell_complete: (self: core.Parameter, ctx: Obj, incomplete: Str) -> Never

.Option: ClassType
.Option <: .Parameter
.Option.show_choices: Bool
.Option.help: Never
.Option.hide_input: Bool
.Option.allow_from_autoenv: Bool
.Option.show_default: Never
.Option.count: Bool
.Option.is_flag: Never
.Option.prompt: Never
.Option.is_bool_flag: Bool
.Option.show_envvar: Bool
.Option.flag_value: Never
.Option.hidden: Bool
.Option.confirmation_prompt: Never
.Option.prompt_required: Bool
.Option._flag_needs_value: Never
.Option.__call__: (param_decls: Obj := Obj, show_default: Obj := Obj, prompt: Obj := Obj, confirmation_prompt: Obj := Obj, prompt_required: Bool := Bool, hide_input: Bool := Bool, is_flag: Obj := Obj, flag_value: Obj := Obj, multiple: Bool := Bool, count: Bool := Bool, allow_from_autoenv: Bool := Bool, Type: Obj := Obj, help: Obj := Obj, hidden: Bool := Bool, show_choices: Bool := Bool, show_envvar: Bool := Bool, **attrs := Obj) -> core.Option
.Option.param_type_name: {"option"}
.Option.to_info_dict: (self: core.Option) -> Never
.Option._parse_decls: (self: core.Option, decls: global::Iterable(Never), expose_value: Bool) -> global::Tuple([{None}, global::List!(Never, 2), global::List!(Never, 1)])
.Option.add_to_parser: (self: core.Option, parser: Obj, ctx: Obj) -> NoneType
.Option.get_help_record: (self: Never, ctx: Obj) -> global::Tuple([Str, Bool])
.Option.get_default: (self: core.Option, ctx: Obj, call: Obj := Obj) -> {Ellipsis}
.Option.get_default: (self: core.Option, ctx: Obj, call: Bool := Bool) -> {Ellipsis}
.Option.get_default: (self: Never, ctx: Obj, call: Bool := Bool) -> Never
.Option.prompt_for_value: (self: core.Option, ctx: Obj) -> Never
.Option.resolve_envvar_value: (self: Never, ctx: Obj) -> {None}
.Option.value_from_envvar: (self: Never, ctx: Obj) -> Never
.Option.consume_value: (self: core.Option, ctx: Obj, opts: Obj) -> global::Tuple([Never, Never])

.Argument: ClassType
.Argument <: .Parameter
.Argument.__call__: (param_decls: Obj, required: Obj := Obj, **attrs := Obj) -> core.Argument
.Argument.param_type_name: {"argument"}
.Argument.human_readable_name: (self: core.Argument) -> Str
.Argument.make_metavar: (self: core.Argument) -> Str
.Argument._parse_decls: (self: core.Argument, decls: Never, expose_value: Bool) -> global::Tuple([Str, global::List!(Never, 1), global::List!(Never, 0)])
.Argument.get_usage_pieces: (self: core.Argument, ctx: Obj) -> global::List!(Str, 1)
.Argument.get_error_hint: (self: core.Argument, ctx: Obj) -> Str
.Argument.add_to_parser: (self: core.Argument, parser: Obj, ctx: Obj) -> NoneType

