##[pylyzer] failed /home/dmitry/progs/python/WISCourse/Python_assignments/day8/venv/lib/python3.10/site-packages/click/types.py 1736025949 36422
.os = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.stat = pyimport "<failure>"


.sys = pyimport "<failure>"


.t = pyimport "<failure>"


.___v_desugar_1 = pyimport "<failure>"

.datetime: Never
.___v_desugar_2 = pyimport "<failure>"

._: Never
.___v_desugar_3 = pyimport "<failure>"

.ngettext: Never
.___v_desugar_4 = pyimport "_compat"
._compat = pyimport "_compat"
._get_argv_encoding: () -> Str
.___v_desugar_5 = pyimport "_compat"

.open_stream: |Type_2396 :> {None}, Type_2396 <: NoneType or Str|(filename: Obj, mode: Str := Str, encoding: Type_2396 := Type_2396, errors: Type_2396 := Type_2396, atomic: Bool := Bool) -> global::Tuple([Never, {True}])
.___v_desugar_6 = pyimport "exceptions"
.exceptions = pyimport "exceptions"
.BadParameter: Never
.___v_desugar_7 = pyimport "utils"
.utils = pyimport "utils"
.format_filename: (filename: Obj, shorten: Bool := Bool and Bool) -> Str
.___v_desugar_8 = pyimport "utils"

.LazyFile: Never
.___v_desugar_9 = pyimport "utils"

.safecall: (func: Obj) -> Never

.ParamType: ClassType
.ParamType.name: Str
.ParamType.__call__: (self: Obj, value: Obj, param: Obj := Obj, ctx: Obj := Obj) -> Never
.ParamType.is_composite: Never
.ParamType.arity: Never
.ParamType.envvar_list_splitter: Never
.ParamType.to_info_dict: (self: types.ParamType) -> global::Dict!({{"name"}: Obj, {"param_type"}: Never})
.ParamType.__call__: (self: Obj, value: Obj, param: Obj := Obj, ctx: Obj := Obj) -> Never
.ParamType.get_metavar: (self: types.ParamType, param: core.Parameter) -> {"Returns the metavar default for this param if it provides one."}
.ParamType.get_missing_message: (self: types.ParamType, param: core.Parameter) -> {"Optionally might return extra information about a missing\n        parameter.\n\n        .. versionadded:: 2.0\n        "}
.ParamType.convert: (self: types.ParamType, value: Obj, param: Obj, ctx: Obj) -> Never
.ParamType.split_envvar_value: (self: types.ParamType, rv: Str) -> Never
.ParamType.fail: (self: types.ParamType, message: Str, param: Obj := Obj, ctx: Obj := Obj) -> Never
.ParamType.shell_complete: (self: types.ParamType, ctx: Obj, param: core.Parameter, incomplete: Str) -> global::List!(Never, 0)

.CompositeParamType: ClassType
types = pyimport "types"
.CompositeParamType <: .ParamType
.CompositeParamType.is_composite: {True}
.CompositeParamType.arity: (self: types.CompositeParamType) -> Int

.FuncParamType: ClassType
.FuncParamType <: .ParamType
.FuncParamType.func: Never
.FuncParamType.name: Str
.FuncParamType.__call__: (func: Obj) -> types.FuncParamType
.FuncParamType.to_info_dict: (self: types.FuncParamType) -> Never
.FuncParamType.convert: (self: types.FuncParamType, value: Obj, param: Obj, ctx: Obj) -> Never

.UnprocessedParamType: ClassType
.UnprocessedParamType <: .ParamType
.UnprocessedParamType.name: {"text"}
.UnprocessedParamType.convert: (self: types.UnprocessedParamType, value: Obj, param: Obj, ctx: Obj) -> Never
.UnprocessedParamType.__repr__: (self: types.UnprocessedParamType) -> Str

.StringParamType: ClassType
.StringParamType <: .ParamType
.StringParamType.name: {"text"}
.StringParamType.convert: (self: types.StringParamType, value: Obj, param: Obj, ctx: Obj) -> Never
.StringParamType.__repr__: (self: types.StringParamType) -> Str

.Choice: ClassType
.Choice <: .ParamType
.Choice.choices: Never
.Choice.case_sensitive: Bool
.Choice.__call__: (choices: Obj, case_sensitive: Bool := Bool) -> types.Choice
.Choice.name: {"choice"}
.Choice.to_info_dict: (self: types.Choice) -> Never
.Choice.get_metavar: (self: types.Choice, param: core.Parameter) -> Str
.Choice.get_missing_message: (self: types.Choice, param: core.Parameter) -> Str
.Choice.convert: |Type_22269 <: Structural({.token_normalize_func = ?33957}), Type_33957: Type|(self: types.Choice, value: Obj, param: Obj, ctx: Type_22269) -> Never
.Choice.__repr__: (self: types.Choice) -> Str
.Choice.shell_complete: (self: types.Choice, ctx: Obj, param: core.Parameter, incomplete: Str) -> global::List!(shell_completion.CompletionItem, _: Nat)

.DateTime: ClassType
.DateTime <: .ParamType
.DateTime.formats: Never
.DateTime.__call__: (formats: Obj := Obj) -> types.DateTime
.DateTime.name: {"datetime"}
.DateTime.to_info_dict: (self: types.DateTime) -> Never
.DateTime.get_metavar: (self: types.DateTime, param: core.Parameter) -> Str
.DateTime._try_to_convert_date: (self: types.DateTime, value: Obj, format: Str) -> Never
.DateTime.convert: (self: types.DateTime, value: Obj, param: Obj, ctx: Obj) -> Never
.DateTime.__repr__: (self: types.DateTime) -> Str

.Type__NumberParamTypeBase: ClassType
.Type__NumberParamTypeBase <: .ParamType
.Type__NumberParamTypeBase._number_class: Never
.Type__NumberParamTypeBase.convert: (self: types.Type__NumberParamTypeBase, value: Obj, param: Obj, ctx: Obj) -> Never

.Type__NumberRangeBase: ClassType
.Type__NumberRangeBase <: .Type__NumberParamTypeBase
.Type__NumberRangeBase.max: Never
.Type__NumberRangeBase.min: Never
.Type__NumberRangeBase.clamp: Bool
.Type__NumberRangeBase.max_open: Bool
.Type__NumberRangeBase.min_open: Bool
.Type__NumberRangeBase.__call__: (min: Obj := Obj, max: Obj := Obj, min_open: Bool := Bool, max_open: Bool := Bool, clamp: Bool := Bool) -> types.Type__NumberRangeBase
.Type__NumberRangeBase.to_info_dict: (self: types.Type__NumberRangeBase) -> Never
.Type__NumberRangeBase.convert: (self: types.Type__NumberRangeBase, value: Obj, param: Obj, ctx: Obj) -> Never
.Type__NumberRangeBase._clamp: (self: types.Type__NumberRangeBase, bound: Float, dir: Obj, open: Bool) -> Float
.Type__NumberRangeBase._describe_range: (self: types.Type__NumberRangeBase) -> Str
.Type__NumberRangeBase.__repr__: (self: types.Type__NumberRangeBase) -> Str

.IntParamType: ClassType
.IntParamType <: .Type__NumberParamTypeBase
.IntParamType.name: {"integer"}
.IntParamType._number_class: {Int}
.IntParamType.__repr__: (self: types.IntParamType) -> Str

.IntRange: ClassType
.IntRange <: .Type__NumberRangeBase
.IntRange.name: {"integer range"}
.IntRange._clamp: (self: types.IntRange, bound: Int, dir: Obj, open: Bool) -> Int

.FloatParamType: ClassType
.FloatParamType <: .Type__NumberParamTypeBase
.FloatParamType.name: {"float"}
.FloatParamType._number_class: {Float}
.FloatParamType.__repr__: (self: types.FloatParamType) -> Str

.FloatRange: ClassType
.FloatRange <: .Type__NumberRangeBase
.FloatRange.__call__: (min: Obj := Obj, max: Obj := Obj, min_open: Bool := Bool, max_open: Bool := Bool, clamp: Bool := Bool) -> types.FloatRange
.FloatRange.name: {"float range"}
.FloatRange._clamp: (self: types.FloatRange, bound: Float, dir: Obj, open: Bool) -> Float

.BoolParamType: ClassType
.BoolParamType <: .ParamType
.BoolParamType.name: {"boolean"}
.BoolParamType.convert: (self: types.BoolParamType, value: Obj, param: Obj, ctx: Obj) -> Never
.BoolParamType.__repr__: (self: types.BoolParamType) -> Str

.UUIDParameterType: ClassType
.UUIDParameterType <: .ParamType
.UUIDParameterType.name: {"uuid"}
.UUIDParameterType.convert: (self: types.UUIDParameterType, value: Obj, param: Obj, ctx: Obj) -> Never
.UUIDParameterType.__repr__: (self: types.UUIDParameterType) -> Str

.File: ClassType
.File <: .ParamType
.File.mode: Str
.File.encoding: Never
.File.atomic: Bool
.File.lazy: Never
.File.errors: Never
.File.__call__: (mode: Str := Str, encoding: Obj := Obj, errors: Obj := Obj, lazy: Obj := Obj, atomic: Bool := Bool) -> types.File
.File.name: {"filename"}
.File.envvar_list_splitter: Never
.File.to_info_dict: (self: types.File) -> Never
.File.resolve_lazy_flag: (self: types.File, value: Obj) -> Bool
.File.convert: (self: types.File, value: Obj, param: Obj, ctx: Obj) -> Never
.File.shell_complete: (self: types.File, ctx: Obj, param: core.Parameter, incomplete: Str) -> global::List!(shell_completion.CompletionItem, 1)

._is_file_like: (value: Obj) -> Never
.Path: ClassType
.Path <: .ParamType
.Path.writable: Bool
.Path.allow_dash: Bool
.Path.file_okay: Bool
.Path.dir_okay: Bool
.Path.readable: Bool
.Path.executable: Bool
.Path.resolve_path: Bool
.Path.exists: Bool
.Path.type: Never
.Path.__call__: (exists: Bool := Bool, file_okay: Bool := Bool, dir_okay: Bool := Bool, writable: Bool := Bool, readable: Bool := Bool, resolve_path: Bool := Bool, allow_dash: Bool := Bool, path_type: Obj := Obj, executable: Bool := Bool) -> types.Path
.Path.envvar_list_splitter: Never
.Path.to_info_dict: (self: types.Path) -> Never
.Path.coerce_path_result: (self: types.Path, value: Obj) -> Never
.Path.convert: (self: types.Path, value: Obj, param: Obj, ctx: Obj) -> Never
.Path.shell_complete: (self: types.Path, ctx: Obj, param: core.Parameter, incomplete: Str) -> global::List!(shell_completion.CompletionItem, 1)

.Tuple: ClassType
.Tuple <: .CompositeParamType
.Tuple.types: Never
.Tuple.__call__: (types: Obj) -> types.Tuple
.Tuple.to_info_dict: (self: types.Tuple) -> Never
.Tuple.name: (self: types.Tuple) -> Str
.Tuple.arity: (self: types.Tuple) -> Int
.Tuple.convert: (self: types.Tuple, value: Obj, param: Obj, ctx: Obj) -> Never

.convert_type: (ty: ClassType, default: Obj := Obj) -> types.ParamType
.UNPROCESSED: Never
.STRING: Never
.INT: Never
.FLOAT: Never
.BOOL: Never
.UUID: Never
