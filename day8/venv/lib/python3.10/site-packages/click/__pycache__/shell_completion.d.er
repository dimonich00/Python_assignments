##[pylyzer] failed /home/dmitry/progs/python/WISCourse/Python_assignments/day8/venv/lib/python3.10/site-packages/click/shell_completion.py 1736025949 18636
.os = pyimport "<failure>"
.<failure> = pyimport "<failure>"

.re = pyimport "<failure>"


.t = pyimport "<failure>"


.___v_desugar_1 = pyimport "<failure>"

._: Never
.___v_desugar_2 = pyimport "core"
.core = pyimport "core"
.Argument: {core.Argument}
.___v_desugar_3 = pyimport "core"

.BaseCommand: {core.BaseCommand}
.___v_desugar_4 = pyimport "core"

.Context: Never
.___v_desugar_5 = pyimport "core"

.MultiCommand: {core.MultiCommand}
.___v_desugar_6 = pyimport "core"

.Option: {core.Option}
.___v_desugar_7 = pyimport "core"

.Parameter: {core.Parameter}
.___v_desugar_8 = pyimport "core"

.ParameterSource: {core.ParameterSource}
.___v_desugar_9 = pyimport "parser"
.parser = pyimport "parser"
.split_arg_string: (string: Str) -> global::List!(Never, 2)
.___v_desugar_10 = pyimport "utils"
.utils = pyimport "utils"
.echo: (message: Never := Never, file: global::Writable! := global::Writable!, nl: Bool := Bool, err: Bool := Bool, color: {None} := {None}) -> NoneType
.shell_complete: (cli: core.BaseCommand, ctx_args: Obj, prog_name: Str, complete_var: Str, instruction: Str) -> Int
.CompletionItem: ClassType
.CompletionItem._info: Never
.CompletionItem.value: Never
.CompletionItem.help: Never
.CompletionItem.type: Str
.CompletionItem.__call__: (value: Obj, Type: Str := Str, help: Obj := Obj, **kwargs := Obj) -> shell_completion.CompletionItem
.CompletionItem.__slots__: global::Tuple([{"value"}, {"type"}, {"help"}, {"_info"}])
.CompletionItem.__getattr__: (self: shell_completion.CompletionItem, name: Str) -> Never

._SOURCE_BASH: {"Type_(complete_func)s() {\n    local IFS=$\'\\n\'\n    local response\n\n    response=$(env COMP_WORDS=\"${COMP_WORDS[*]}\" COMP_CWORD=$COMP_CWORD Type_(complete_var)s=bash_complete $1)\n\n    for completion in $response; do\n        IFS=\',\' read type value <<< \"$completion\"\n\n        if [[ $type == \'dir\' ]]; then\n            COMPREPLY=()\n            compopt -o dirnames\n        elif [[ $type == \'file\' ]]; then\n            COMPREPLY=()\n            compopt -o default\n        elif [[ $type == \'plain\' ]]; then\n            COMPREPLY+=($value)\n        fi\n    done\n\n    return 0\n}\n\nType_(complete_func)s_setup() {\n    complete -o nosort -F Type_(complete_func)s Type_(prog_name)s\n}\n\nType_(complete_func)s_setup;\n"}
._SOURCE_ZSH: {"#compdef Type_(prog_name)s\n\nType_(complete_func)s() {\n    local -a completions\n    local -a completions_with_descriptions\n    local -a response\n    (( ! $+commands[Type_(prog_name)s] )) && return 1\n\n    response=(\"${(@f)$(env COMP_WORDS=\"${words[*]}\" COMP_CWORD=$((CURRENT-1)) Type_(complete_var)s=zsh_complete Type_(prog_name)s)}\")\n\n    for type key descr in ${response}; do\n        if [[ \"$type\" == \"plain\" ]]; then\n            if [[ \"$descr\" == \"_\" ]]; then\n                completions+=(\"$key\")\n            else\n                completions_with_descriptions+=(\"$key\":\"$descr\")\n            fi\n        elif [[ \"$type\" == \"dir\" ]]; then\n            _path_files -.\n        elif [[ \"$type\" == \"file\" ]]; then\n            _path_files -f\n        fi\n    done\n\n    if [ -n \"$completions_with_descriptions\" ]; then\n        _describe -V unsorted completions_with_descriptions -U\n    fi\n\n    if [ -n \"$completions\" ]; then\n        compadd -U -V unsorted -a completions\n    fi\n}\n\nif [[ $zsh_eval_context[-1] == loadautofunc ]]; then\n    # autoload from fpath, call function directly\n    Type_(complete_func)s \"$@\"\nelse\n    # eval.source.. command, register function for later\n    compdef Type_(complete_func)s Type_(prog_name)s\nfi\n"}
._SOURCE_FISH: {"function Type_(complete_func)s;\n    set -l response (env Type_(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) COMP_CWORD=(commandline -t) Type_(prog_name)s);\n\n    for completion in $response;\n        set -l metadata (string split \",\" $completion);\n\n        if test $metadata[1] = \"dir\";\n            __fish_complete_directories $metadata[2];\n        else if test $metadata[1] = \"file\";\n            __fish_complete_path $metadata[2];\n        else if test $metadata[1] = \"plain\";\n            echo $metadata[2];\n        end;\n    end;\nend;\n\ncomplete --no-files --command Type_(prog_name)s --arguments \"(Type_(complete_func)s)\";\n"}
.ShellComplete: ClassType
.ShellComplete.source_template: Never
.ShellComplete.ctx_args: Never
.ShellComplete.complete_var: Str
.ShellComplete.name: Never
.ShellComplete.cli: core.BaseCommand
.ShellComplete.prog_name: Str
.ShellComplete.__call__: (cli: core.BaseCommand, ctx_args: Obj, prog_name: Str, complete_var: Str) -> shell_completion.ShellComplete
.ShellComplete.func_name: (self: shell_completion.ShellComplete) -> Str
.ShellComplete.source_vars: (self: shell_completion.ShellComplete) -> global::Dict!({{"complete_var"}: Str, {"complete_func"}: (self: shell_completion.ShellComplete) -> Str, {"prog_name"}: Str})
.ShellComplete.source: (self: shell_completion.ShellComplete) -> Str
.ShellComplete.get_completion_args: (self: shell_completion.ShellComplete) -> Never
.ShellComplete.get_completions: (self: shell_completion.ShellComplete, args: Obj, incomplete: Str) -> Never
.ShellComplete.format_completion: (self: shell_completion.ShellComplete, item: shell_completion.CompletionItem) -> Str
.ShellComplete.complete: (self: shell_completion.ShellComplete) -> Str

.BashComplete: ClassType
shell_completion = pyimport "shell_completion"
.BashComplete <: .ShellComplete
.BashComplete.name: {"bash"}
.BashComplete.source_template: {"Type_(complete_func)s() {\n    local IFS=$\'\\n\'\n    local response\n\n    response=$(env COMP_WORDS=\"${COMP_WORDS[*]}\" COMP_CWORD=$COMP_CWORD Type_(complete_var)s=bash_complete $1)\n\n    for completion in $response; do\n        IFS=\',\' read type value <<< \"$completion\"\n\n        if [[ $type == \'dir\' ]]; then\n            COMPREPLY=()\n            compopt -o dirnames\n        elif [[ $type == \'file\' ]]; then\n            COMPREPLY=()\n            compopt -o default\n        elif [[ $type == \'plain\' ]]; then\n            COMPREPLY+=($value)\n        fi\n    done\n\n    return 0\n}\n\nType_(complete_func)s_setup() {\n    complete -o nosort -F Type_(complete_func)s Type_(prog_name)s\n}\n\nType_(complete_func)s_setup;\n"}
.BashComplete._check_version: () -> NoneType
.BashComplete.source: (self: shell_completion.BashComplete) -> Str
.BashComplete.get_completion_args: (self: shell_completion.BashComplete) -> global::Tuple([global::List!(Never, _: Nat), {""}])
.BashComplete.format_completion: (self: shell_completion.BashComplete, item: shell_completion.CompletionItem) -> Str

.ZshComplete: ClassType
.ZshComplete <: .ShellComplete
.ZshComplete.name: {"zsh"}
.ZshComplete.source_template: {"#compdef Type_(prog_name)s\n\nType_(complete_func)s() {\n    local -a completions\n    local -a completions_with_descriptions\n    local -a response\n    (( ! $+commands[Type_(prog_name)s] )) && return 1\n\n    response=(\"${(@f)$(env COMP_WORDS=\"${words[*]}\" COMP_CWORD=$((CURRENT-1)) Type_(complete_var)s=zsh_complete Type_(prog_name)s)}\")\n\n    for type key descr in ${response}; do\n        if [[ \"$type\" == \"plain\" ]]; then\n            if [[ \"$descr\" == \"_\" ]]; then\n                completions+=(\"$key\")\n            else\n                completions_with_descriptions+=(\"$key\":\"$descr\")\n            fi\n        elif [[ \"$type\" == \"dir\" ]]; then\n            _path_files -.\n        elif [[ \"$type\" == \"file\" ]]; then\n            _path_files -f\n        fi\n    done\n\n    if [ -n \"$completions_with_descriptions\" ]; then\n        _describe -V unsorted completions_with_descriptions -U\n    fi\n\n    if [ -n \"$completions\" ]; then\n        compadd -U -V unsorted -a completions\n    fi\n}\n\nif [[ $zsh_eval_context[-1] == loadautofunc ]]; then\n    # autoload from fpath, call function directly\n    Type_(complete_func)s \"$@\"\nelse\n    # eval.source.. command, register function for later\n    compdef Type_(complete_func)s Type_(prog_name)s\nfi\n"}
.ZshComplete.get_completion_args: (self: shell_completion.ZshComplete) -> global::Tuple([global::List!(Never, _: Nat), {""}])
.ZshComplete.format_completion: (self: shell_completion.ZshComplete, item: shell_completion.CompletionItem) -> Str

.FishComplete: ClassType
.FishComplete <: .ShellComplete
.FishComplete.name: {"fish"}
.FishComplete.source_template: {"function Type_(complete_func)s;\n    set -l response (env Type_(complete_var)s=fish_complete COMP_WORDS=(commandline -cp) COMP_CWORD=(commandline -t) Type_(prog_name)s);\n\n    for completion in $response;\n        set -l metadata (string split \",\" $completion);\n\n        if test $metadata[1] = \"dir\";\n            __fish_complete_directories $metadata[2];\n        else if test $metadata[1] = \"file\";\n            __fish_complete_path $metadata[2];\n        else if test $metadata[1] = \"plain\";\n            echo $metadata[2];\n        end;\n    end;\nend;\n\ncomplete --no-files --command Type_(prog_name)s --arguments \"(Type_(complete_func)s)\";\n"}
.FishComplete.get_completion_args: (self: shell_completion.FishComplete) -> global::Tuple([global::List!(Never, _: Nat), Never])
.FishComplete.format_completion: (self: shell_completion.FishComplete, item: shell_completion.CompletionItem) -> Str

.ShellCompleteType: Never
._available_shells: Never
.add_completion_class: (cls: Obj, name: Obj := Obj) -> Never
.get_completion_class: (shell: Str) -> (core.BaseCommand, Obj, Str, Str) -> Never
._is_incomplete_argument: (ctx: Obj, param: core.Parameter) -> Bool
._start_of_option: (ctx: Obj, value: Str) -> Bool
._is_incomplete_option: (ctx: Obj, args: global::Sequence(Never), param: core.Parameter) -> Bool
._resolve_context: (cli: core.BaseCommand, ctx_args: global::Dict!(_: global::GenericDict), prog_name: Str, args: Obj) -> Never
._resolve_incomplete: (ctx: Obj, args: Obj, incomplete: Str) -> global::Tuple([Never, Never])
